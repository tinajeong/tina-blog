---
title: 'Typescript 샘플 프로젝트'
thumbSrc: '/static/images/typescript.webp'
date: '2022-07-16'
tags: ['typescript']
draft: false
summary: 'Maximilian Schwarzmüller의 강의를 들으며 내용을 정리합니다.'
images: ['/static/images/typescript.webp']
---

# 📌 목차

![typescript](/static/images/typescript.webp)

---

## TypeScript의 HTMLElement
`HTMLElement`는 자바스크립트에서도 존재하는 최상위 인터페이스로, 각종 element, node, event listener 들이 `HTMLElement`의 구현체이다.
타입스크립트는 각종 html elements를 타입으로 선언해 사용할 수 있도록 정의해두었다.

```typescript
templateElement: HTMLTemplateElement;
hostElement: HTMLDivElement;
element: HTMLFormElement;
```
> [타입스크립트 DOM API](https://github.com/microsoft/TypeScript/blob/main/lib/lib.dom.d.ts)

## this의 맥락과 Autobind
configure 함수에서 이벤트 리스너를 설정하고, `this.submitHandler` 메소드를 인자로 넘긴다. 
아무런 설정이 없다면 `submitHandler` 구현부에서의 this는 ProjectInput 클래스가 아니다. 이벤트가 발생되어 호출된 시점에서는 event가 this가 되기 때문이다.
그래서 매핑되는 this를 bind함수만 사용하거나 데코레이터도 사용해 변경해주어야 한다.
```typescript
// autobind decorator
function autobind(
  _: any, // 사용하지 않을 파라미터
  _2: string, // 사용하지 않을 파라미터 2
  descriptor: PropertyDescriptor
) {
  const originalMethod = descriptor.value;
  const adjDescriptor: PropertyDescriptor = {
    configurable: true,
    get() {
      const boundFn = originalMethod.bind(this);
      return boundFn; // bind 대상 변경
    }
  };
  return adjDescriptor;
}
...
@autobind
private submitHandler(event: Event) {
    event.preventDefault();
    console.log(this.titleInputElement.value);
}

private configure() {
    this.element.addEventListener('submit', this.submitHandler);
}
```

## 재사용할 수 있는 Input Validation 
아래는 `Validatable`이라는 인터페이스를 선언하고, 해당 타입을 인자로 받는 validate 함수를 구현해 사용자 입력에 대한 검증로직을 통일하고 일반화한 코드이다.
```typescript
// Validation
interface Validatable {
  value: string | number;
  required?: boolean;
  minLength?: number;
  maxLength?: number;
  min?: number;
  max?: number;
}

function validate(validatableInput: Validatable) {
  let isValid = true;
  if (validatableInput.required) {
    isValid = isValid && validatableInput.value.toString().trim().length !== 0;
  }
  if (
    validatableInput.minLength != null &&
    typeof validatableInput.value === 'string'
  ) {
    isValid =
      isValid && validatableInput.value.length >= validatableInput.minLength;
  }
  if (
    validatableInput.maxLength != null &&
    typeof validatableInput.value === 'string'
  ) {
    isValid =
      isValid && validatableInput.value.length <= validatableInput.maxLength;
  }
  if (
    validatableInput.min != null &&
    typeof validatableInput.value === 'number'
  ) {
    isValid = isValid && validatableInput.value >= validatableInput.min;
  }
  if (
    validatableInput.max != null &&
    typeof validatableInput.value === 'number'
  ) {
    isValid = isValid && validatableInput.value <= validatableInput.max;
  }
  return isValid;
}
```
위와 같이 해두면, 해당 기능을 사용하는 클라이언트입장에서는 추상화되고 깔끔한 방식으로 검증을 수행할 수 있다.
```typescript
const titleValidatable: Validatable = {
    value: enteredTitle,
    required: true
};
const descriptionValidatable: Validatable = {
    value: enteredDescription,
    required: true,
    minLength: 5
};
const peopleValidatable: Validatable = {
    value: +enteredPeople,
    required: true,
    min: 1,
    max: 5
};

if (
    !validate(titleValidatable) ||
    !validate(descriptionValidatable) ||
    !validate(peopleValidatable)
) {
    alert('Invalid input, please try again!');
    return;
} else {
    return [enteredTitle, enteredDescription, +enteredPeople];
}
```

## 싱글톤 패턴으로 상태관리하기
```typescript
enum ProjectStatus {
  Active,
  Finished
}

class Project {
  constructor(
    public id: string,
    public title: string,
    public description: string,
    public people: number,
    public status: ProjectStatus
  ) {}
}

type Listener = (items: Project[]) => void;

class ProjectState {
  private listeners: Listener[] = [];
  private projects: Project[] = [];
  private static instance: ProjectState;

  private constructor() {}

  static getInstance() { // 객체가 존재하지 않을때만 생성해 리턴
    if (this.instance) {
      return this.instance;
    }
    this.instance = new ProjectState();
    return this.instance;
  }

  addListener(listenerFn: Listener) {
    this.listeners.push(listenerFn);
  }

  addProject(title: string, description: string, numOfPeople: number) {
    const newProject = new Project(
      Math.random().toString(),
      title,
      description,
      numOfPeople,
      ProjectStatus.Active // default는 active
    );
    this.projects.push(newProject);
    for (const listenerFn of this.listeners) {
      listenerFn(this.projects.slice()); // deep copy
    }
  }
}

const projectState = ProjectState.getInstance();

```
## References
- https://typescript-kr.github.io/pages/tutorials/dom-manipulation.html
- https://developer.mozilla.org/ko/docs/Web/API/HTMLElement
- https://stackoverflow.com/questions/597588/how-do-you-clone-an-array-of-objects-in-javascript
